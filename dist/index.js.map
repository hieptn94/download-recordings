{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/download.ts","../src/recording.ts","../src/downloadRecordings.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Command } from \"commander\";\nimport { readFileSync } from \"fs\";\nimport { dirname, join } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport createClient from \"./client\";\nimport download from \"./download\";\nimport PQueue from \"p-queue\";\nimport ky from \"ky\";\nimport downloadRecordings from \"./downloadRecordings\";\nimport _ from \"lodash\";\n\n// Get package.json for version info\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nconst packageJsonPath = join(__dirname, \"..\", \"package.json\");\nconst packageJson = JSON.parse(readFileSync(packageJsonPath, \"utf-8\"));\n\n// Create the main program\nconst program = new Command();\n\n// Configure the program\nprogram\n  .name(\"download-recordings\")\n  .description(\"Download recordings from a specified URL within a date range\")\n  .version(packageJson.version);\n\n// Add the download-recordings command\nprogram\n  .command(\"download\")\n  .description(\"Download recordings from a specified URL\")\n  .requiredOption(\"-s, --start-date <date>\", \"start date (YYYY-MM-DD format)\")\n  .requiredOption(\"-e, --end-date <date>\", \"end date (YYYY-MM-DD format)\")\n  .requiredOption(\"-u, --url <url>\", \"URL to download recordings from\")\n  .requiredOption(\"-t, --token <token>\", \"authentication token\")\n  .option(\n    \"-o, --output <path>\",\n    \"output directory for downloads\",\n    \"./downloads\"\n  )\n  .option(\"-v, --verbose\", \"enable verbose logging\")\n  .option(\n    \"--dry-run\",\n    \"show what would be downloaded without actually downloading\"\n  )\n  .action(\n    async (options: {\n      startDate: string;\n      endDate: string;\n      url: string;\n      output: string;\n      token: string;\n      verbose: boolean;\n      dryRun: boolean;\n    }) => {\n      console.log(options);\n      const { startDate, endDate, url, token, output, verbose, dryRun } =\n        options;\n\n      if (verbose) {\n        console.log(\"Download Recordings CLI\");\n        console.log(\"======================\");\n        console.log(`Start Date: ${startDate}`);\n        console.log(`End Date: ${endDate}`);\n        console.log(`URL: ${url}`);\n        console.log(`Token: ${token.substring(0, 8)}...`);\n        console.log(`Output Directory: ${output}`);\n        console.log(`Dry Run: ${dryRun ? \"Yes\" : \"No\"}`);\n        console.log(\"\");\n      }\n\n      const start = new Date(startDate);\n      const end = new Date(endDate);\n\n      if (start > end) {\n        console.error(\"Error: start-date must be before end-date\");\n        process.exit(1);\n      }\n\n      try {\n        if (dryRun) {\n          console.log(\"DRY RUN: Would download recordings from:\");\n          console.log(`  URL: ${url}`);\n          console.log(`  Date Range: ${startDate} to ${endDate}`);\n          console.log(`  Output Directory: ${output}`);\n          return;\n        }\n\n        console.log(\"Starting download process...\");\n\n        const queue = new PQueue({ concurrency: 10 });\n        const downloadMultipleRecordings = downloadRecordings(ky.extend({}))(\n          queue\n        );\n\n        const client = createClient({\n          url,\n          token,\n        });\n        const downloadPage = download(client);\n\n        console.log(\"Downloading first page...\");\n        const firstPage = await downloadPage({\n          startDate,\n          endDate,\n          page: 1,\n        });\n\n        const firstUrls = firstPage.data.cdr_data.data.map(\n          (c) => c.record_file\n        );\n\n        console.log(\"Downloading first page recordings...\");\n        await downloadMultipleRecordings({\n          urls: firstUrls,\n          directory: output,\n        });\n\n        console.log(\"Downloading other pages...\");\n        const otherPages = _.range(1, 2400).slice(1);\n        for (let i = 0; i < otherPages.length; i++) {\n          const page = otherPages[i];\n          try {\n            console.log(`Downloading page ${page}...`);\n            const response = await downloadPage({\n              startDate,\n              endDate,\n              page,\n            });\n            const urls = response.data.cdr_data.data.map((c) => c.record_file);\n            console.log(\n              `Downloaded ${urls.length} recordings from page ${page}`\n            );\n            await downloadMultipleRecordings({\n              urls,\n              directory: output,\n            });\n          } catch (error) {\n            console.error(`Error downloading page ${page}:`, error);\n          }\n        }\n\n        console.log(\"Download completed successfully!\");\n        console.log(\"Downloaded recordings:\");\n        console.log(firstUrls);\n        console.log(otherPages);\n      } catch (error) {\n        console.error(\"Error during download:\", error);\n        process.exit(1);\n      }\n    }\n  );\n\n// Global options\nprogram\n  .option(\"-v, --verbose\", \"enable verbose logging\")\n  .option(\"--dry-run\", \"show what would be done without executing\")\n  .hook(\"preAction\", (thisCommand) => {\n    const options = thisCommand.opts();\n    if (options.verbose) {\n      console.log(\"Verbose mode enabled\");\n    }\n    if (options.dryRun) {\n      console.log(\"Dry run mode - no changes will be made\");\n    }\n  });\n\n// Parse arguments\nprogram.parse();\n\n// Export for testing\nexport { program };\n","import ky, { KyInstance } from \"ky\";\n\ntype Options = {\n  url: string;\n  token: string;\n};\n\nconst createClient = (options: Options): KyInstance =>\n  ky.extend({\n    prefixUrl: options.url,\n    timeout: 50_000,\n    hooks: {\n      beforeRequest: [\n        (request) => {\n          console.log({ url: request.url });\n          request.headers.set(\"Authorization\", `Bearer ${options.token}`);\n        },\n      ],\n    },\n  });\n\nexport default createClient;\n","import { KyInstance } from \"ky\";\nimport { Response } from \"./types\";\n\ntype Options = {\n  startDate: string;\n  endDate: string;\n  page: number;\n};\n\nconst download =\n  (client: KyInstance) =>\n  async (options: Options): Promise<Response> => {\n    const response = await client.post(\"api/histories\", {\n      json: {\n        datefilter_to: options.endDate,\n        datefilter_from: options.startDate,\n        typeDuration: \"=\",\n        page: options.page,\n        per_page: 10,\n        search: \"\",\n        status_call: \"ANSWERED\",\n      },\n    });\n\n    return response.json<Response>();\n  };\n\nexport default download;\n","import { createWriteStream } from \"fs\";\nimport { mkdir } from \"fs/promises\";\nimport { KyInstance } from \"ky\";\nimport PQueue from \"p-queue\";\nimport { basename, join } from \"path\";\nimport { pipeline } from \"stream/promises\";\n\ntype DownloadOptions = {\n  url: string;\n  directory: string;\n};\n\ntype DownloadResult = {\n  url: string;\n  filePath: string;\n  size: number;\n  success: boolean;\n  error?: string;\n};\n\nconst downloadRecording = (client: KyInstance) => (queue: PQueue) => {\n  return async (\n    downloadOptions: DownloadOptions\n  ): Promise<DownloadResult | void> => {\n    const { url, directory } = downloadOptions;\n\n    return queue.add(async (): Promise<DownloadResult | void> => {\n      try {\n        const extractedFilename = basename(new URL(url).pathname);\n        const filePath = join(directory, extractedFilename);\n\n        await mkdir(directory, { recursive: true });\n\n        const response = await client.get(url);\n\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const contentLength = parseInt(\n          response.headers.get(\"content-length\") || \"0\"\n        );\n\n        const writeStream = createWriteStream(filePath);\n\n        if (!response.body) throw new Error(\"Response body is null\");\n\n        await pipeline(response.body, writeStream);\n\n        return {\n          url,\n          filePath,\n          size: contentLength,\n          success: true,\n        };\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n\n        return {\n          url,\n          filePath: \"\",\n          size: 0,\n          success: false,\n          error: errorMessage,\n        };\n      }\n    });\n  };\n};\n\nexport default downloadRecording;\n","import { KyInstance } from \"ky\";\nimport PQueue from \"p-queue\";\nimport downloadRecording from \"./recording\"; // Adjust import path as needed\n\ntype DownloadOptions = {\n  url: string;\n  directory: string;\n};\n\ntype DownloadResult = {\n  url: string;\n  filePath: string;\n  size: number;\n  success: boolean;\n  error?: string;\n};\n\ntype DownloadRecordingsOptions = {\n  urls: string[];\n  directory: string;\n};\n\ntype DownloadRecordingsResult = {\n  results: DownloadResult[];\n  successful: number;\n  failed: number;\n  totalSize: number;\n  summary: {\n    successfulUrls: string[];\n    failedUrls: string[];\n  };\n};\n\nconst downloadRecordings = (client: KyInstance) => (queue: PQueue) => {\n  const downloadSingle = downloadRecording(client)(queue);\n\n  return async (\n    options: DownloadRecordingsOptions\n  ): Promise<DownloadRecordingsResult> => {\n    const { urls, directory } = options;\n\n    try {\n      // Create download promises for all URLs\n      const downloadPromises = urls.map((url) =>\n        downloadSingle({ url, directory })\n      );\n\n      // Wait for all downloads to complete\n      const results = await Promise.all(downloadPromises);\n\n      // Filter out void results and ensure we have DownloadResult[]\n      const downloadResults = results.filter(\n        (result): result is DownloadResult => result !== undefined\n      );\n\n      // Calculate statistics\n      const successful = downloadResults.filter(\n        (result) => result.success\n      ).length;\n      const failed = downloadResults.filter((result) => !result.success).length;\n      const totalSize = downloadResults\n        .filter((result) => result.success)\n        .reduce((sum, result) => sum + result.size, 0);\n\n      // Create summary\n      const successfulUrls = downloadResults\n        .filter((result) => result.success)\n        .map((result) => result.url);\n\n      const failedUrls = downloadResults\n        .filter((result) => !result.success)\n        .map((result) => result.url);\n\n      return {\n        results: downloadResults,\n        successful,\n        failed,\n        totalSize,\n        summary: {\n          successfulUrls,\n          failedUrls,\n        },\n      };\n    } catch (error) {\n      // Handle unexpected errors\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n\n      // Create failed results for all URLs\n      const failedResults: DownloadResult[] = urls.map((url) => ({\n        url,\n        filePath: \"\",\n        size: 0,\n        success: false,\n        error: errorMessage,\n      }));\n\n      return {\n        results: failedResults,\n        successful: 0,\n        failed: urls.length,\n        totalSize: 0,\n        summary: {\n          successfulUrls: [],\n          failedUrls: urls,\n        },\n      };\n    }\n  };\n};\n\nexport default downloadRecordings;\n"],"mappings":"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","names":["join","ky","join","ky"]}